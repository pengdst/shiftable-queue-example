// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package main

import (
	"context"

	"github.com/rabbitmq/amqp091-go"
	mock "github.com/stretchr/testify/mock"
)

// NewMockRestAPI creates a new instance of MockRestAPI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRestAPI(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRestAPI {
	mock := &MockRestAPI{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRestAPI is an autogenerated mock type for the RestAPI type
type MockRestAPI struct {
	mock.Mock
}

type MockRestAPI_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRestAPI) EXPECT() *MockRestAPI_Expecter {
	return &MockRestAPI_Expecter{mock: &_m.Mock}
}

// SimulateProcessing provides a mock function for the type MockRestAPI
func (_mock *MockRestAPI) SimulateProcessing(queue *Queue) error {
	ret := _mock.Called(queue)

	if len(ret) == 0 {
		panic("no return value specified for SimulateProcessing")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*Queue) error); ok {
		r0 = returnFunc(queue)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRestAPI_SimulateProcessing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SimulateProcessing'
type MockRestAPI_SimulateProcessing_Call struct {
	*mock.Call
}

// SimulateProcessing is a helper method to define mock.On call
//   - queue *Queue
func (_e *MockRestAPI_Expecter) SimulateProcessing(queue interface{}) *MockRestAPI_SimulateProcessing_Call {
	return &MockRestAPI_SimulateProcessing_Call{Call: _e.mock.On("SimulateProcessing", queue)}
}

func (_c *MockRestAPI_SimulateProcessing_Call) Run(run func(queue *Queue)) *MockRestAPI_SimulateProcessing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *Queue
		if args[0] != nil {
			arg0 = args[0].(*Queue)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockRestAPI_SimulateProcessing_Call) Return(err error) *MockRestAPI_SimulateProcessing_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRestAPI_SimulateProcessing_Call) RunAndReturn(run func(queue *Queue) error) *MockRestAPI_SimulateProcessing_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPublisher creates a new instance of MockPublisher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPublisher(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPublisher {
	mock := &MockPublisher{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPublisher is an autogenerated mock type for the Publisher type
type MockPublisher struct {
	mock.Mock
}

type MockPublisher_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPublisher) EXPECT() *MockPublisher_Expecter {
	return &MockPublisher_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockPublisher
func (_mock *MockPublisher) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPublisher_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockPublisher_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockPublisher_Expecter) Close() *MockPublisher_Close_Call {
	return &MockPublisher_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockPublisher_Close_Call) Run(run func()) *MockPublisher_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPublisher_Close_Call) Return(err error) *MockPublisher_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPublisher_Close_Call) RunAndReturn(run func() error) *MockPublisher_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Consume provides a mock function for the type MockPublisher
func (_mock *MockPublisher) Consume(queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp091.Table) (<-chan amqp091.Delivery, error) {
	ret := _mock.Called(queue, consumer, autoAck, exclusive, noLocal, noWait, args)

	if len(ret) == 0 {
		panic("no return value specified for Consume")
	}

	var r0 <-chan amqp091.Delivery
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string, bool, bool, bool, bool, amqp091.Table) (<-chan amqp091.Delivery, error)); ok {
		return returnFunc(queue, consumer, autoAck, exclusive, noLocal, noWait, args)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, bool, bool, bool, bool, amqp091.Table) <-chan amqp091.Delivery); ok {
		r0 = returnFunc(queue, consumer, autoAck, exclusive, noLocal, noWait, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan amqp091.Delivery)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, bool, bool, bool, bool, amqp091.Table) error); ok {
		r1 = returnFunc(queue, consumer, autoAck, exclusive, noLocal, noWait, args)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPublisher_Consume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Consume'
type MockPublisher_Consume_Call struct {
	*mock.Call
}

// Consume is a helper method to define mock.On call
//   - queue string
//   - consumer string
//   - autoAck bool
//   - exclusive bool
//   - noLocal bool
//   - noWait bool
//   - args amqp091.Table
func (_e *MockPublisher_Expecter) Consume(queue interface{}, consumer interface{}, autoAck interface{}, exclusive interface{}, noLocal interface{}, noWait interface{}, args interface{}) *MockPublisher_Consume_Call {
	return &MockPublisher_Consume_Call{Call: _e.mock.On("Consume", queue, consumer, autoAck, exclusive, noLocal, noWait, args)}
}

func (_c *MockPublisher_Consume_Call) Run(run func(queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp091.Table)) *MockPublisher_Consume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		var arg4 bool
		if args[4] != nil {
			arg4 = args[4].(bool)
		}
		var arg5 bool
		if args[5] != nil {
			arg5 = args[5].(bool)
		}
		var arg6 amqp091.Table
		if args[6] != nil {
			arg6 = args[6].(amqp091.Table)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
		)
	})
	return _c
}

func (_c *MockPublisher_Consume_Call) Return(deliveryCh <-chan amqp091.Delivery, err error) *MockPublisher_Consume_Call {
	_c.Call.Return(deliveryCh, err)
	return _c
}

func (_c *MockPublisher_Consume_Call) RunAndReturn(run func(queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp091.Table) (<-chan amqp091.Delivery, error)) *MockPublisher_Consume_Call {
	_c.Call.Return(run)
	return _c
}

// PublishWithContext provides a mock function for the type MockPublisher
func (_mock *MockPublisher) PublishWithContext(ctx context.Context, exchange string, key string, mandatory bool, immediate bool, msg amqp091.Publishing) error {
	ret := _mock.Called(ctx, exchange, key, mandatory, immediate, msg)

	if len(ret) == 0 {
		panic("no return value specified for PublishWithContext")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, bool, bool, amqp091.Publishing) error); ok {
		r0 = returnFunc(ctx, exchange, key, mandatory, immediate, msg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPublisher_PublishWithContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishWithContext'
type MockPublisher_PublishWithContext_Call struct {
	*mock.Call
}

// PublishWithContext is a helper method to define mock.On call
//   - ctx context.Context
//   - exchange string
//   - key string
//   - mandatory bool
//   - immediate bool
//   - msg amqp091.Publishing
func (_e *MockPublisher_Expecter) PublishWithContext(ctx interface{}, exchange interface{}, key interface{}, mandatory interface{}, immediate interface{}, msg interface{}) *MockPublisher_PublishWithContext_Call {
	return &MockPublisher_PublishWithContext_Call{Call: _e.mock.On("PublishWithContext", ctx, exchange, key, mandatory, immediate, msg)}
}

func (_c *MockPublisher_PublishWithContext_Call) Run(run func(ctx context.Context, exchange string, key string, mandatory bool, immediate bool, msg amqp091.Publishing)) *MockPublisher_PublishWithContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		var arg4 bool
		if args[4] != nil {
			arg4 = args[4].(bool)
		}
		var arg5 amqp091.Publishing
		if args[5] != nil {
			arg5 = args[5].(amqp091.Publishing)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockPublisher_PublishWithContext_Call) Return(err error) *MockPublisher_PublishWithContext_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPublisher_PublishWithContext_Call) RunAndReturn(run func(ctx context.Context, exchange string, key string, mandatory bool, immediate bool, msg amqp091.Publishing) error) *MockPublisher_PublishWithContext_Call {
	_c.Call.Return(run)
	return _c
}

// QueueDeclare provides a mock function for the type MockPublisher
func (_mock *MockPublisher) QueueDeclare(name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp091.Table) (amqp091.Queue, error) {
	ret := _mock.Called(name, durable, autoDelete, exclusive, noWait, args)

	if len(ret) == 0 {
		panic("no return value specified for QueueDeclare")
	}

	var r0 amqp091.Queue
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, bool, bool, bool, bool, amqp091.Table) (amqp091.Queue, error)); ok {
		return returnFunc(name, durable, autoDelete, exclusive, noWait, args)
	}
	if returnFunc, ok := ret.Get(0).(func(string, bool, bool, bool, bool, amqp091.Table) amqp091.Queue); ok {
		r0 = returnFunc(name, durable, autoDelete, exclusive, noWait, args)
	} else {
		r0 = ret.Get(0).(amqp091.Queue)
	}
	if returnFunc, ok := ret.Get(1).(func(string, bool, bool, bool, bool, amqp091.Table) error); ok {
		r1 = returnFunc(name, durable, autoDelete, exclusive, noWait, args)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPublisher_QueueDeclare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueueDeclare'
type MockPublisher_QueueDeclare_Call struct {
	*mock.Call
}

// QueueDeclare is a helper method to define mock.On call
//   - name string
//   - durable bool
//   - autoDelete bool
//   - exclusive bool
//   - noWait bool
//   - args amqp091.Table
func (_e *MockPublisher_Expecter) QueueDeclare(name interface{}, durable interface{}, autoDelete interface{}, exclusive interface{}, noWait interface{}, args interface{}) *MockPublisher_QueueDeclare_Call {
	return &MockPublisher_QueueDeclare_Call{Call: _e.mock.On("QueueDeclare", name, durable, autoDelete, exclusive, noWait, args)}
}

func (_c *MockPublisher_QueueDeclare_Call) Run(run func(name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp091.Table)) *MockPublisher_QueueDeclare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		var arg4 bool
		if args[4] != nil {
			arg4 = args[4].(bool)
		}
		var arg5 amqp091.Table
		if args[5] != nil {
			arg5 = args[5].(amqp091.Table)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockPublisher_QueueDeclare_Call) Return(queue amqp091.Queue, err error) *MockPublisher_QueueDeclare_Call {
	_c.Call.Return(queue, err)
	return _c
}

func (_c *MockPublisher_QueueDeclare_Call) RunAndReturn(run func(name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp091.Table) (amqp091.Queue, error)) *MockPublisher_QueueDeclare_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCloser creates a new instance of MockCloser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCloser(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCloser {
	mock := &MockCloser{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCloser is an autogenerated mock type for the Closer type
type MockCloser struct {
	mock.Mock
}

type MockCloser_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCloser) EXPECT() *MockCloser_Expecter {
	return &MockCloser_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockCloser
func (_mock *MockCloser) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCloser_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockCloser_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockCloser_Expecter) Close() *MockCloser_Close_Call {
	return &MockCloser_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockCloser_Close_Call) Run(run func()) *MockCloser_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCloser_Close_Call) Return(err error) *MockCloser_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCloser_Close_Call) RunAndReturn(run func() error) *MockCloser_Close_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockQueueTrigger creates a new instance of MockQueueTrigger. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQueueTrigger(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQueueTrigger {
	mock := &MockQueueTrigger{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockQueueTrigger is an autogenerated mock type for the QueueTrigger type
type MockQueueTrigger struct {
	mock.Mock
}

type MockQueueTrigger_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQueueTrigger) EXPECT() *MockQueueTrigger_Expecter {
	return &MockQueueTrigger_Expecter{mock: &_m.Mock}
}

// TriggerProcessing provides a mock function for the type MockQueueTrigger
func (_mock *MockQueueTrigger) TriggerProcessing(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for TriggerProcessing")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockQueueTrigger_TriggerProcessing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TriggerProcessing'
type MockQueueTrigger_TriggerProcessing_Call struct {
	*mock.Call
}

// TriggerProcessing is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQueueTrigger_Expecter) TriggerProcessing(ctx interface{}) *MockQueueTrigger_TriggerProcessing_Call {
	return &MockQueueTrigger_TriggerProcessing_Call{Call: _e.mock.On("TriggerProcessing", ctx)}
}

func (_c *MockQueueTrigger_TriggerProcessing_Call) Run(run func(ctx context.Context)) *MockQueueTrigger_TriggerProcessing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockQueueTrigger_TriggerProcessing_Call) Return(err error) *MockQueueTrigger_TriggerProcessing_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockQueueTrigger_TriggerProcessing_Call) RunAndReturn(run func(ctx context.Context) error) *MockQueueTrigger_TriggerProcessing_Call {
	_c.Call.Return(run)
	return _c
}
